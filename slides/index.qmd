---
title: "Pr√°tica Avan√ßada de Data Science e Visualization"
author: "Insper 2022-33"
format: 
  revealjs:
    self-contained: true
    hash-type: number
    footer: "2022"
    logo: logo.png
    theme: [simple, custom.scss]
execute:
  freeze: true
---

## Sobre mim

```{r}
#| echo: false
#| warning: false
#| message: false
library(tidyverse)
library(dados)
```

Meu nome √© Julio. Eu gosto de MasterChef

![](masterchef.gif)

## Sobre mim

Eu n√£o gosto de

-   Captchas
-   tretas R vs python

![](captcha.jpg){.absolute left="25%" bottom="10%" width="50%"}

## Meu papel

Meu papel nessa disciplina ser√° ajudar no aprendizado da parte t√©cnica -- c√≥digos etc.

::: incremental
-   Tamb√©m posso dar pitacos nas apresenta√ß√µes e salv√°-los em situa√ß√µes de desespero (atendimentos extras).
:::

## Lab 01

Nesse lab, nosso objetivo ser√° construir solu√ß√µes em **R** e **python** para problemas comuns de transforma√ß√£o de dados.

::: incremental
-   Equipes de **3 pessoas**. Come√ßaremos com uma aloca√ß√£o por afinidade. Dependendo dos resultados, realocamos.

-   Eu serei o Google. Na parte do R, verificarei se voc√™s fizeram tudo certo. Na parte do python, voc√™s v√£o me ensinar.

-   No final de cada exerc√≠cio, discutiremos aspectos te√≥ricos sobre as ferramentas (se necess√°rio).
:::

## Pr√™mios

-   As melhores resolu√ß√µes receber√£o stickers. A quantidade de stickers depende da dificuldade do exerc√≠cio.

![](stickers.jpg){.absolute left="25%" bottom="10vh" width="50%"}

## Vamos l√°!

![](cat.gif){.absolute left="25%" bottom="10vh" width="50%"}

## Exerc√≠cio 1 (transforma√ß√£o) üõë

::: panel-tabset
### Entrada

```{r}
#| echo: true
pinguins
```

### Tarefa

-   Selecionar especie, ilha, comprimento do bico
-   Filtrar valores vazios
-   Agrupar por esp√©cie
-   Calcular m√©dia e mediana
-   Calcular a diferen√ßa absoluta da m√©dia e mediana

### Sa√≠da R

```{r}
#| echo: false
res <- pinguins |> 
  select(especie, ilha, comprimento_bico) |> 
  filter(!is.na(comprimento_bico)) |> 
  # drop_na(comprimento_bico) |> 
  group_by(especie) |> 
  summarise(
    media = mean(comprimento_bico),
    mediana = median(comprimento_bico)
  ) |> 
  arrange(desc(mediana)) |> 
  mutate(diferenca = abs(media - mediana))
res
```

### Sa√≠da Python

```{python}
#| echo: false
#| eval: false

import pandas as pd

media = r.pinguins[['especie', 'comprimento_bico']].dropna().groupby('especie').mean().rename(columns = {"comprimento_bico" : "media"})

mediana = r.pinguins[['especie', 'comprimento_bico']].dropna().groupby('especie').median().rename(columns = {"comprimento_bico" : "mediana"})

tabela = pd.merge(media, mediana, on = ['especie'], how = 'left')

tabela['dif'] = abs(tabela['media'] - tabela['mediana'])

tabela.sort_values('dif', ascending = False)

pinguins = r.pinguins

pinguins['comprimento_bico2'] = pinguins['comprimento_bico']

tabela = pinguins[["especie", "comprimento_bico", "comprimento_bico2"]].dropna().groupby("especie").agg({"comprimento_bico":"mean", "comprimento_bico2":"median"}).reset_index().rename(columns = {"comprimento_bico":"media", "comprimento_bico2":"mediana"}).


tabela['dif'] = abs(tabela['media'] - tabela['mediana'])
tabela.sort_values('dif', ascending = False)
```
:::

## Exerc√≠cio 2 (pivotagem) üõëüõë

::: panel-tabset
### Entrada

```{r}
dados_oms
```

### Tarefa

-   empilhar as colunas "novos_fpp", jogando as outras "novos\_\*" fora
-   filtrar ano maior ou igual a 2008 e pa√≠ses do resultado
-   agrupar por pa√≠s e ano
-   somar a quantidade total de casos
-   jogar a coluna ano nas colunas

### Sa√≠da R

```{r}
res <- dados_oms |> 
  pivot_longer(starts_with("novos_fpp")) |> 
  select(-contains("novos")) |> 
  filter(
    ano >= 2008, 
    !is.na(value),
    pais %in% c("Estados Unidos", "Brasil", "√çndia")
  ) |> 
  select(pais, ano, value) |>
  pivot_wider(
    names_from = ano, 
    values_from = value,
    values_fn = sum
  )
  
res
```

### Sa√≠da Python

```{python}
import pandas as pd
pd.set_option('display.max_columns', None)
r.res
```
:::

## Exerc√≠cio 3 (joins) üõëüõëüõëüõë

::: panel-tabset
### Entrada

::: {style="overflow:auto;height:450px"}
```{r}
#| echo: true
print(clima, n = 1)
print(aeroportos, n = 1)
print(companhias_aereas, n = 1)
print(avioes, n = 1)
print(voos, n = 1)
```
:::

### Tarefa

-   juntar voos, clima, companhias a√©reas e avi√µes
-   retirar fabricante vazio e retirar origem "EWR"
-   agrupar por fabricante, nome e origem
-   obter quantidade de v√¥os e temperatura m√©dia
-   ordenar pela quantidade
-   mostrar resultados com \> 5 mil observa√ß√µes

### Sa√≠da R

```{r}
#| echo: false
res <- voos |> 
  left_join(
    clima,
    c("ano", "mes", "dia", "hora", "origem")
  ) |> 
  left_join(companhias_aereas, "companhia_aerea") |> 
  left_join(avioes, c("cauda" = "codigo_cauda")) |> 
  filter(!is.na(fabricante), origem != "EWR") |> 
  group_by(fabricante, nome, origem) |> 
  summarise(
    n = n(), 
    .groups = "drop",
    temperatura_media = mean(temperatura, na.rm = TRUE)
  ) |> 
  arrange(desc(n)) |> 
  filter(n > 5000)

res
```

### Sa√≠da Python

```{python}
#| echo: false
r.res
```
:::

## Exerc√≠cio 4 (feat eng) üõëüõëüõëüõëüõë

::: panel-tabset
### Objetivo

-   Melhorar o poder preditivo do modelo sem mudar nada na parte da modelagem
-   Vamos mexer apenas nas preditoras

### Base de dados

```{r}
#| echo: true
voos_select <- voos |> 
  select(
    ano, mes, dia, hora,
    companhia_aerea, cauda,
    origem, destino,
    y = atraso_saida
  ) |> 
  drop_na(y)

voos_select
```

### Fun√ß√£o objetivo

```{r}
#| cache: true
#| echo: true
#| code-line-numbers: "|1-4|6-10|12-13|15-19"
set.seed(1)
split <- rsample::initial_split(voos_select, prop = .8)
treino <- rsample::training(split)
teste <- rsample::testing(split)

feat_eng <- function(dados) {
  # ...exercicio...
  dados |> 
    select(-cauda)
}

treino_eng <- feat_eng(treino)
teste_eng <- feat_eng(teste) # cuidado

modelo <- parsnip::rand_forest("regression", trees = 20) |>  
  parsnip::set_engine("ranger")
fitted <- parsnip::fit(modelo, y ~ ., data = treino_eng)
preds <- predict(fitted, new_data = teste_eng)
result_antes <- yardstick::rmse_vec(teste_eng$y, preds$.pred)
```

### Meta

Resultado antes:

```{r}
#| echo: false
#| cache: true
result_antes
```

Resultado depois:

```{r}
#| echo: false
#| cache: true
feat_eng <- function(dados) {
  dados |> 
    left_join(
      clima,
      c("ano", "mes", "dia", "hora", "origem")
    ) |> 
    left_join(companhias_aereas, "companhia_aerea") |> 
    left_join(avioes, c("cauda" = "codigo_cauda")) |> 
    select(
      -ano.x, -cauda, -data_hora, -ano.y,
      -velocidade, -velocidade_rajada,
      -tipo, -fabricante, -modelo, -tipo_motor
    ) |> 
    mutate(across(
      where(is.numeric),
      replace_na, 5
    ))
}

treino_eng <- feat_eng(treino)
teste_eng <- feat_eng(teste) # cuidado

modelo <- parsnip::rand_forest("regression", trees = 20) |>  
  parsnip::set_engine("ranger")
fitted <- parsnip::fit(modelo, y ~ ., data = treino_eng)
preds <- predict(fitted, new_data = teste_eng)
yardstick::rmse_vec(teste_eng$y, preds$.pred)
```
:::

# Lab 02 - ggplot2

## Lab 02

Nesse lab, nosso objetivo ser√° construir solu√ß√µes em ggplot2 para gr√°ficos estat√≠sticos.

-   Os grupos s√£o os que montamos para o trabalho final.

-   As tarefas ser√£o imitar um gr√°fico que eu montei para voc√™s usando ggplot2. Eu mostrarei apenas a imagem. Posso dar dicas no meio do caminho.

-   O grupo que conseguir fazer o gr√°fico primeiro ganhar√° **pr√™mios**.

-   Quem fizer vers√µes em python dos gr√°ficos para me ensinar ganhar√° **pr√™mios**.

## Base olist

Utilizaremos a base de dados da **olist**, para que voc√™s possam aproveitar os trabalhos nas atividades integradoras.

::: incremental
-   Teoricamente, voc√™s j√° t√™m uma base de dados arrumada em m√£os, por conta dos exerc√≠cios do curso de Design.

-   Para garantir que as visualiza√ß√µes funcionam, no entanto, disponibilizei uma base que eu montei (pode conter erros) [no material dos labs](https://github.com/padsInsper/202233-padsv/raw/main/material.zip).

-   A base est√° tanto em `.parquet` (usar pacote [`{arrow}`](https://arrow.apache.org/docs/r/) quanto em `.rds`. Use a que for mais confort√°vel.

-   Se quiser usar sua pr√≥pria base, sem problemas!
:::

---

#### Exerc√≠cio 01 üç™

::: panel-tabset

#### Resultado esperado

```{r}
#| fig-align: center
#| out-width: 90%
knitr::include_graphics("ex01.png")
```

#### Dicas

- Usar a coluna `types`

- Estudar a fun√ß√£o `theme()`

- As `geom_label()` ficam na metade da altura da barra.

#### C√≥digo

```{r}
#| eval: false
#| echo: true
#' Author:
#' Subject:


# Import -----------------------------------------------------------------------
# readr::write_rds(d, "")

library(ggplot2)


# grafico 1 ---------------------------------------------------------------


items |> 
  dplyr::count(types) |> 
  dplyr::mutate(types = forcats::fct_reorder(types, n)) |> 
  dplyr::filter(n > 100) |> 
  dplyr::mutate(n = n/1000) |> 
  ggplot(aes(x = n, y = types)) +
  geom_col(fill = "#8ae3d7", width = .5) +
  geom_label(aes(label = round(n, 2), x = n/2)) +
  theme_dark(16) +
  labs(
    x = "Quantidade\n(milhares)",
    y = "Forma de pagamento",
    title = "Formas de pagamento mais comuns",
    subtitle = "Considerando tipos com mais de 100 observa√ß√µes",
    caption = "Fonte: Olist"
  ) +
  theme(
    panel.background = element_rect(fill = "gray20"),
    plot.background = element_rect(fill = "gray10"),
    text = element_text(family = "serif", colour = "white"),
    axis.text = element_text(family = "serif", colour = "white"),
    panel.grid.minor = element_blank()
  )


# grafico 2 ---------------------------------------------------------------

items |> 
  dplyr::mutate(
    data = as.Date(order_purchase_timestamp),
    data = lubridate::floor_date(data, "month"),
    estado = forcats::fct_other(
      seller_state, 
      keep = c("SP", "RJ"), 
      other_level = "Outros"
    )
  ) |>
  dplyr::filter(
    data >= "2017-01-01",
    data <= "2018-07-01"
  ) |> 
  dplyr::count(data, estado) |> 
  ggplot() +
  aes(x = data, y = n, colour = estado) +
  geom_line(size = 2) +
  scale_color_viridis_d(begin = .2, end = .8) +
  labs(
    x = "Data", 
    y = "Quantidade", 
    title = "S√£o Paulo tem mais vendas",
    subtitle = "O que √© esperado, pois a popula√ß√£o √© maior üò¨",
    caption = "Fonte: Olist",
    color = "Estado"
  ) +
  scale_x_date(
    date_breaks = "3 month", 
    date_labels = "%b\n%Y"
  ) +
  theme_light(15) +
  theme(
    legend.position = "bottom"
  )
  

# grafico 04 --------------------------------------------------------------

estados <- geobr::read_state()

set.seed(42)
items |> 
  dplyr::count(
    seller_state,
    geolocation_lat_seller,
    geolocation_lng_seller,
    geolocation_lat_customer,
    geolocation_lng_customer
  ) |> 
  dplyr::filter(seller_state %in% c("SP", "MG", "RJ")) |> 
  dplyr::slice_sample(n = 1000) |> 
  ggplot() +
  geom_sf(data = estados, fill = "gray95", size = .1) +
  geom_curve(
    mapping = aes(
      x = geolocation_lng_seller,
      y = geolocation_lat_seller,
      xend = geolocation_lng_customer,
      yend = geolocation_lat_customer
    ), 
    arrow = arrow(length = unit(0.1, "inches")),
    curvature = .2,
    alpha = .2,
    colour = "royalblue"
  ) +
  facet_wrap(~seller_state, strip.position = "bottom") +
  theme_void(base_size = 16) +
  labs(
    title = "Para onde v√£o as compras?",
    subtitle = "Comparando S√£o Paulo, Minas Gerais e Rio de Janeiro",
    caption = "Fonte: Olist"
  ) 




```


:::

---

#### Exerc√≠cio 02 üç™üç™

::: panel-tabset

#### Resultado esperado

```{r}
#| fig-align: center
#| out-width: 90%
knitr::include_graphics("ex02.png")
```

#### Dicas

- Usar `scale_x_date()`

- Estudar `scale_color_viridis_d()`

- `lubridate::floor_date()` para aproximar datas

- `case_when()` ou `fct_other()` para reclassificar uma vari√°vel categ√≥rica

- filtrar a base para o intervalo de datas entre "2017-01-01" e "2018-07-01"

- devemos contar/agrupar por `data` (m√™s) e `estado`

#### C√≥digo

```{r}
#| eval: false
#| echo: true

items |> 
  dplyr::mutate(
    data = as.Date(order_purchase_timestamp),
    data = lubridate::floor_date(data, "month"),
    estado = forcats::fct_other(
      seller_state, 
      keep = c("SP", "RJ"), 
      other_level = "Outros"
    )
  ) |>
  dplyr::filter(
    data >= "2017-01-01",
    data <= "2018-07-01"
  ) |> 
  dplyr::count(data, estado) |> 
  ggplot() +
  aes(x = data, y = n, colour = estado) +
  geom_line(size = 2) +
  scale_color_viridis_d(begin = .2, end = .8) +
  labs(
    x = "Data", 
    y = "Quantidade", 
    title = "S√£o Paulo tem mais vendas",
    subtitle = "O que √© esperado, pois a popula√ß√£o √© maior üò¨",
    caption = "Fonte: Olist",
    color = "Estado"
  ) +
  scale_x_date(
    date_breaks = "3 month", 
    date_labels = "%b\n%Y"
  ) +
  theme_light(15) +
  theme(
    legend.position = "bottom"
  )

```


:::


---

#### Exerc√≠cio 03 üç™üç™üç™

::: panel-tabset

#### Resultado esperado

```{r}
#| fig-align: center
#| out-width: 90%
knitr::include_graphics("ex03.png")
```

#### Dicas

- Usar o pacote `{ggridges}`.

- Para pintar apenas uma categoria, crie uma coluna.

- Para anota√ß√µes no gr√°fico (como "Mediana"), use a fun√ß√£o `annotate()`.

- Para fazer os reais, use a fun√ß√£o `scales::scales_dollar_format()`.

#### C√≥digo

```{r}
#| eval: false
#| echo: true

items_agg <- items |> 
  group_by(product_category_name) |> 
  filter(n() > 4000) |> 
  ungroup() |> 
  mutate(
    product_category_name = fct_reorder(
      product_category_name, price, median
    ),
    relogios = ifelse(
      product_category_name == "relogios_presentes",
      "destacar", "n√£o destacar"
    )
  )

mediana <- items_agg |> 
  summarise(mediana = median(price))

items_agg |> 
  ggplot() +
  aes(x = price, y = product_category_name, fill = relogios) +
  ggridges::geom_density_ridges(
    quantile_lines = TRUE,
    quantiles = 2,
    na.rm = FALSE,
    n = 2048, 
    show.legend = FALSE
  ) +
  scale_x_continuous(
    limits = c(0, NA),
    labels = scales::dollar_format(prefix = "R$")
  ) +
  coord_cartesian(xlim = c(0, 300)) +
  geom_vline(
    aes(xintercept = mediana), 
    data = mediana,
    linetype = 2,
    colour = "red"
  ) + 
  scale_fill_manual(
    values = c("#6686e6", "#eaeaea")
  ) +
  theme_minimal()
```


:::

---

#### Exerc√≠cio 04 üç™üç™üç™üç™

::: panel-tabset

#### Resultado esperado

```{r}
#| fig-align: center
#| out-width: 90%
knitr::include_graphics("ex04.png")
```

#### Dicas

- Fa√ßa uma amostra de 1000 observa√ß√µes dos dados, com `set.seed(42)`

- Para obter o mapa, usar o pacote `{geobr}`

- Para plotar o mapa, usar a fun√ß√£o `geom_sf()`

- Estamos desenhando CURVAS

- Use facets

#### C√≥digo

```{r}
#| echo: true
#| eval: false

estados <- geobr::read_state()

set.seed(42)
items |> 
  dplyr::count(
    seller_state,
    geolocation_lat_seller,
    geolocation_lng_seller,
    geolocation_lat_customer,
    geolocation_lng_customer
  ) |> 
  dplyr::filter(seller_state %in% c("SP", "MG", "RJ")) |> 
  dplyr::slice_sample(n = 1000) |> 
  ggplot() +
  geom_sf(data = estados, fill = "gray95", size = .1) +
  geom_curve(
    mapping = aes(
      x = geolocation_lng_seller,
      y = geolocation_lat_seller,
      xend = geolocation_lng_customer,
      yend = geolocation_lat_customer
    ), 
    arrow = arrow(length = unit(0.1, "inches")),
    curvature = .2,
    alpha = .2,
    colour = "royalblue"
  ) +
  facet_wrap(~seller_state, strip.position = "bottom") +
  theme_void(base_size = 16) +
  labs(
    title = "Para onde v√£o as compras?",
    subtitle = "Comparando S√£o Paulo, Minas Gerais e Rio de Janeiro",
    caption = "Fonte: Olist"
  ) 

```


:::

# Lab 02 - shiny e flexdashboard

## {flexdashboard} {.smaller}

O pacote `flexdashboard` oferece um layout de R Markdown para construir dashboards est√°ticos diretamente do R.

Um dashboard est√°tico √© aquele que n√£o exige um servidor com uma sess√£o de R rodando por tr√°s. Dashboards gerados com `flexdashboard` s√£o apenas um arquivo `.html`, que pode ser enviado para qualquer usu√°rio e tudo o que ele precisar√° para abrir o arquivo √© um navegador (Firefox, Chrome etc), isto √©, ele n√£o precisar√° do R ou RStudio instalado na m√°quina dele para visualizar o seu trabalho.

Por usar RMarkdown, tudo o que precisaremos aprender para construir um flexdashboard √© qual marca√ß√£o deveremos usar para construir cada elemento do dashboard.

## Shiny {.smaller}

Shiny √© um framework em linguagem R para a cria√ß√£o de aplicativos web. Por n√£o exigir conhecimento pr√©vio de HTML, CSS e JavaScript, ele democratiza o acesso a essa √°rea de desenvolvimento, permitindo a cria√ß√£o de aplicativos bonitos e complexos a partir de um script R.

Um aplicativo Shiny pode ser reduzido a v√°rios elementos:

- uma p√°gina web: ele ser√° acessado por um navegador, possuir√° um endere√ßo (URL) e ser√° constitu√≠do por HTML, CSS e JavaScript.

- um aplicativo web: permitir√° que quem estiver acessando intereja com as visualiza√ß√µes apresentadas.

- um c√≥digo (ou uma cole√ß√£o de c√≥digos) em linguagem R: constru√≠dos, sobretudo, com o pacote `{shiny}`.

## Diferen√ßas entre flexdashboard e shiny {.smaller}

Por ser est√°tico, o flexdashboard permite o compartilhamento dos resultados como arquivo, podendo ser passado como anexo. No entanto, ele tem limita√ß√µes na customiza√ß√£o e em poder computacional.

> O [flexdashboard](https://curso-r.github.io/main-dashboards/archive/extra-flexdashboard.html#2) √© indicado para __apresenta√ß√µes__.

J√° o shiny √© muito mais robusto e completo, permitindo fazer quaisquer intera√ß√µes entre o R e a web. √â mais dif√≠cil de programar e precisa de um servidor na nuvem para rodar. O deploy √© bem f√°cil, mas necess√°rio.

> O flexdashboard √© indicado para __produtos__.

## E o python?

![Neymar falando sobre python](neymar.jpg)
## Python para shiny!

<center>
### [https://shiny.rstudio.com/py](https://shiny.rstudio.com/py)
</center>

Conta ainda com uma vers√£o "shinylive", permitindo rodar shiny diretamente do navegador ü§©

Alternativa: [Dash (plotly)](https://plotly.com/)

## Componentes b√°sicos {.smaller}

Um aplicativo Shiny tem dois componentes b√°sicos: a **interface de usu√°rio** e o **servidor**.

- Constru√ß√£o do c√≥digo HTML que comp√µe o app. Podemos pensar na programa√ß√£o desse c√≥digo HTML como a constru√ß√£o daquilo que ser√° mostrado na tela, a cara do seu app, a interface de usu√°rio ou **UI** (sigla para o termo *user interface*, em ingl√™s).

- Coisas que n√£o ser√£o vistas por quem utilizar o app: o **servidor**. O lado do servidor (*server side* ou simplesmente *server*, em ingl√™s) cont√©m toda a l√≥gica para a constru√ß√£o das sa√≠das apresentadas na UI.

## A UI

A figura a seguir mostra a UI de um app bem simples, que permite a escolha de duas vari√°veis e apresenta o gr√°fico de dispers√£o delas:

```{r, echo = FALSE}
knitr::include_graphics("img/app_penguins_disp.png")
```

## O servidor {.smaller}

Embora precisemos aprender alguns conceitos e regras novas, a maior parte do c√≥digo que comp√µe o servidor √© aquele bom e velho R que j√° utilizamos no dia-a-dia para gerar tabelas, gr√°ficos e qualquer outro tipo de visualiza√ß√£o. 

> Em resumo, para fazer um ggplot aparecer no Shiny, basta adaptar o c√≥digo que gera esse gr√°fico para receber as entradas de quem estiver usando o app (*inputs*) e devolver o resultado (*output*) no *lugar* adequado.

- Na figura do slide anterior, o c√≥digo que gera o gr√°fico de dispers√£o fica dentro do servidor.

## Juntando tudo

```{r, echo = FALSE, out.width="90%", fig.align='center'}
knitr::include_graphics("img/esquema_ui_servidor.png")
```

## Estrutura de um c√≥digo Shiny

O c√≥digo de qualquer aplicativo em Shiny ter√° a estrutura abaixo:

- Um objeto chamado `ui`.

- Uma fun√ß√£o chamada `server`.

- Uma chamada da fun√ß√£o `shinyApp()`.

```{r, eval=FALSE}
library(shiny)

ui <- fluidPage("Ol√°, mundo!")

server <- function(input, output, session) {
  
}

shinyApp(ui, server)
```

## UI: o que o usu√°rio v√™ {.smaller}

No objeto `ui`, constru√≠mos o que ser√° mostrado na tela para o usu√°rio. Nele, devemos:

- Construir o layout do aplicativo.

- Definir quais visualiza√ß√µes ser√£o mostradas (tabelas, gr√°ficos, mapas etc).

- Definir elementos de CSS e JavaScript. **[avan√ßado]**

Todas as fun√ß√µes que utilizarmos para criar o `ui` retornar√£o c√≥digo HTML. O objeto `ui`, portanto, ser√° um grande c√≥digo HTML.

```{r, eval=FALSE}
ui <- fluidPage("Ol√°, mundo!")
#> <div class="container-fluid">Ol√°, mundo!</div>
```

**Neste contexto, ser√£o sin√¥nimos**: UI, interface de usu√°rio, *front-end*, *front*.


## HTML, CSS, JS... pra que serve?

Se voc√™ n√£o conhece essas linguagens, uma boa maneira de entender o papel de cada uma delas na constru√ß√£o de um site √© pensar em uma casa. 

- Podemos pensar o HTML como a estrutura f√≠sica da casa: ch√£o, paredes, colunas, teto, encanamento, fia√ß√£o etc.

- O CSS √© o respons√°vel pela apar√™ncia: pintura, pisos, azulejos, decora√ß√£o em geral.

- O JavaScript traz funcionalidades a cada c√¥modo: pia, vaso sanit√°rio, geladeira, cama, televis√£o e por a√≠ vai.

## Programando em HTML sem saber HTML

Com o Shiny, podemos produzir aplicativos web em HTML, CSS e JavaScript sem saber programar nessas linguagens. E melhor: sem sair do R!

<center>
<img src="img/shiny.png" width = "50%">
<img src="img/shiny2.png" width = "50%">
<br>
Fonte: <a href = http://www.rstudio.com/shiny/>rstudio.com/shiny/</a>
</center>

## Server: onde a m√°gica acontece {.smaller}

A fun√ß√£o `server()` vai receber nossos usuais c√≥digos R de manipular bases, gerar tabelas, gr√°ficos, mapas e qualquer outra visualiza√ß√£o que quisermos construir.

A fun√ß√£o `server()` sempre ter√° os par√¢metros:

- `input`: uma lista com todos par√¢metros que o usu√°rio pode mexer.

- `output`: uma lista com todas as visualiza√ß√µes que vamos mostrar para o usu√°rio.

- `session`: uma lista com informa√ß√µes da sess√£o que est√° rodando o aplicativo.

**Neste contexto, ser√£o sin√¥nimos**: server, servidor, *back-end*.

## Rodando um aplicativo {.smaller}

Enquanto estamos desenvolvendo um aplicativo Shiny, queremos test√°-lo localmente para verificar se tudo funciona corretamente. 

> Testar localmente significa que **o seu pr√≥prio computador far√° as vezes de servidor**, embora isso n√£o signifique que seu app ficar√° dispon√≠vel na internet.

No RStudio, podemos rodar nossos apps:

- rodando o script que cont√©m o nosso app;

- clicando no bot√£o **Run App**;

- rodando no console a fun√ß√£o `runApp("caminho/ate/app.R)`.


## O bot√£o Run App

```{r, echo = FALSE, fig.alt="Bot√£o Run App no Rstudio. Fica logo acima do script."}
knitr::include_graphics("img/botao_run_app.png")
```

Ao clicar nesse bot√£o, o seu navegador padr√£o ser√° aberto e voc√™ ver√° a UI do nosso modesto app com apenas a frase "Ol√°, mundo!".

## Sess√£o ocupada {.smaller}

Se voc√™ voltar ao RStudio, eventualmente vai notar algo muito importante: a sua sess√£o de R estar√° ocupada! Isso acontece porque todo Shiny app precisa de uma sess√£o de R rodando por tr√°s.

Essa sess√£o fornece a comunica√ß√£o da UI (ou do nosso navegador) com o servidor e √© respons√°vel por atualizar as visualiza√ß√µes apresentadas na UI, sempre que algu√©m interagir com o app. Embora o nosso app *Ol√°, mundo* n√£o possuir interatividade, a estrutura necess√°ria para que a interatividade aconte√ßa ainda assim √© criada pelo Shiny.

## Liberando a sess√£o e endere√ßo do app {.smaller}

Para liberar a sess√£o, basta clicar no bot√£o "*stop*", na parte de cima do Console, ou pressionar a tecla `Esc`. Veja que, ao fazer isso, a tela do app ficar√° acizentada, indicando que ele foi desconectado do servidor e n√£o funcionar√° mais corretamente.

```{r, echo = FALSE, fig.alt="Console do RStudio com sinal de ocupado (stop).", out.width="60%"}
knitr::include_graphics("img/console_sessao_ocupada.png")
```

Repare que a mensagem no Console representa o *endere√ßo* do nosso aplicativo. Nesse caso, ser√° um IP (`http://127.0.0.1`) com alguma porta que esteja dispon√≠vel escolhida aleatoriamente (`:4028`). Esse endere√ßo aparecer√° no nosso navegador e poderemos copi√°-lo e col√°-lo em qualquer outra aba ou navegador que quisermos rodar o app.

## Atividade

Vamos criar e rodar o exemplo minimal do slide anterior.

<center>
<img src="https://media.giphy.com/media/JIX9t2j0ZTN9S/giphy.gif" width = "300" height = "300">
<br>
<br>

Ao RStudio: `01-ola-mundo.R`

<center>

# Interatividade

## Inputs e Outputs

Uma das principais tarefas no desenvolvimento de um Shiny app √© a defini√ß√£o e constru√ß√£o dos inputs e outputs. S√£o esses elementos que nos permitem interagir com o app.

```{r, echo = FALSE}
knitr::include_graphics("img/app_penguins_disp.png")
```

## Outputs: tabelas, gr√°ficos e muito mais! {.smaller}

Outputs representam as *sa√≠das* do nosso aplicativo, isto √©, tudo que queremos que nosso c√≥digo R retorne para o usu√°rio. Essas sa√≠das podem ser tabelas, gr√°ficos, mapas, texto, imagens ou qualquer outro elemento em HTML.

Os outputs s√£o definidos na UI e criados no server. Cada tipo de output √© definido por uma fun√ß√£o do tipo `*Output()`. Veja as principais fun√ß√µes dessa fam√≠lia:

```{r, echo = FALSE, eval=TRUE, out.width="100%"}
tibble::tribble(~Fun√ß√£o, ~`Sa√≠da`,
                "plotOutput()", "Gr√°ficos",
                "tableOutput()", "Tabelas",
                "textOutput()", "Textos") %>%
  reactable::reactable(
    sortable = FALSE
  )
```

## Fun√ß√µes render {.smaller}

Para criar um output, precisamos das fun√ß√µes do tipo `render*()`. Essas fun√ß√µes s√£o respons√°veis por conectar as nossas visualiza√ß√µes criadas pelo R com o c√≥digo HTML do UI. Na grande maioria dos casos, teremos o par `visualizacaoOutput()` `renderVisualizacao()`. 

Veja a seguir as principais fun√ß√µes `render*()` e como elas se comunicam com as fun√ß√µes `*Output()`.

```{r, echo = FALSE, eval=TRUE}
tibble::tribble(~`*Output()`, ~`render*()`,
                "plotOutput()", "renderPlot()",
                "tableOutput()", "renderTable()",
                "textOutput()", "renderText()") %>%
  reactable::reactable(
    sortable = FALSE
  )
```

## Acessando outputs no server {.smaller}

O argumento `outputId` das fun√ß√µes `_Output()` √© utilizado para nos referirmos aos outputs dentro do server. Todos os outputs criados ficar√£o dentro da lista `output`.

```{r, eval=FALSE}
library(shiny)

ui <- fluidPage(
  "Histograma da vari√°vel mpg",
  plotOutput(outputId = "histograma")
)

server <- function(input, output, session) {
  
  output$histograma <- renderPlot({
    hist(mtcars$mpg)
  })
  
}

shinyApp(ui, server)
```

## Acessando outputs no server {.smaller}

No c√≥digo do slide anterior:

- a fun√ß√£o `plotOutput()` especifica o lugar na UI ser√° colocado o histograma (no caso, logo abaixo do texto `"Histograma da vari√°vel mpg"`);

- para criar o histograma, atribu√≠mos o resultado da fun√ß√£o `renderPlot()` ao valor `histograma` da lista `output`, mesmo nome dado ao argumento `outputId` na fun√ß√£o `plotOutput()`;

- a fun√ß√£o `renderPlot()`, assim com qualquer outra fun√ß√£o da fam√≠lia `render*()`, recebe como primeiro argumento o c√≥digo para gerar o output;

- o histograma √© gerado com o c√≥digo `hist(mtcars$mpg)`.

## Atividade

Vamos criar e rodar um shiny app com um gr√°fico como output.

<br>

<center>
<img src="https://media.giphy.com/media/JIX9t2j0ZTN9S/giphy.gif" width = "300" height = "300">
<br>
<br>
Ao RStudio: `02-output.R`
<center>

## Inputs: d√™ controle ao usu√°rio {.smaller}

Inputs representam as entradas do nosso aplicativo, isto √©, a maneira como informa√ß√µes s√£o transmitidas entre a pessoa usando o app e o servidor. Essas informa√ß√µes podem ser valores, textos, datas, arquivos ou at√© mesmo cliques em um bot√£o.

Para facilitar a escolha desses valores, o pacote `shiny` possibilita diversas op√ß√µes de *widgets*, a depender do tipo de valor a ser passado.

Voc√™ pode conferir a lista de widgets do pacote `shiny` [nesta p√°gina](https://shiny.rstudio.com/gallery/widget-gallery.html). Repare que no campo `Current Value(s)` √© mostrado qual valor ser√° levado para dentro da fun√ß√£o `server` em cada caso.

## Criando inputs

Para criar esses widgets utilizamos as fam√≠lias de fun√ß√µes `*Input()` ou `*Button`.

De forma an√°loga ao `outputId` das fun√ß√µes `*Output()`, todas essas fun√ß√µes possuem `inputId` como primeiro argumento, que recebe uma string e ser√° utilizado para acessar cada input dentro da fun√ß√£o `server`.

Isso implica que **dois inputs n√£o podem ter o mesmo `inputId`**. Apenas o primeiro input funcionar√° caso voc√™ crie dois ou mais `inputId` repetidos.

## Acessando os inputs no server {.smaller}

Para acessar os inputs dentro da fun√ß√£o server, utilizamos a lista `input`. Essa lista guardar√° todos os inputs criados no UI.

:::: {.columns}

::: {.column width="50%"}
<img src="img/inputvalues.png" width= "100%">
:::

::: {.column width="50%"}
<img src="img/sliderinputexample.png" width= "80%">
- `input$num` pode ser usado no server para deixar as visualiza√ß√µes din√¢micas.
:::

::::

<center>
Fonte: <a href = http://www.rstudio.com/shiny/>rstudio.com/shiny/</a>
</center>

## Atividade

Colocar um seletor de vari√°veis para permitir que o usu√°rio escolha a vari√°vel exibida no histograma.

<br>

<center>
<img src="https://media.giphy.com/media/JIX9t2j0ZTN9S/giphy.gif" width = "300" height = "300">
<br>
<br>
Ao RStudio: `03-output-input.R`
</center>

## Atividade

Vamos fazer um app com dois pares input/output independentes.

<br>

<center>
<img src="https://media.giphy.com/media/JIX9t2j0ZTN9S/giphy.gif" width = "300" height = "300">
<br>
<br>
Ao RStudio: `04-dois-inputs-outputs.R`
</center>

## Shinyapps.io {.smaller}

O [shinyapps.io](https://www.shinyapps.io/) √© um servi√ßo do RStudio para hospedagem de Shiny apps.

A conta gratuita permite voc√™ ter at√© 5 aplica√ß√µes e 25 horas mensais de uso (um aplicativo utilizado por 1 hora consome 1 hora do seu plano, 2 aplicativos utilizados simultaneamente por 1 hora consomem 2 horas do seu plano).

Criada uma conta, voc√™ poder√° subir o seu app para o shinyapps.io diretamente do RStudio. Para isso, voc√™ precisar√° apenas conectar a sua conta com o RStudio.

[Neste v√≠deo](https://www.youtube.com/watch?v=jRXubw0kOrg&ab_channel=Curso-R), mostramos como conectar o shinyapps.io com o RStudio.

## Atividade

Vamos conectar o nosso RStudio com o shinyapps.io e subir um app para l√°.

<br>

<center>
<img src="https://media.giphy.com/media/JIX9t2j0ZTN9S/giphy.gif" width = "300" height = "300">
<br>
<br>

Ao RStudio: `04-dois-inputs-outputs.R`

</center>

## Refer√™ncias e material extra

### Tutoriais

- [Tutorial de Shiny do Garrett Grolemund](https://shiny.rstudio.com/tutorial/)

- [Mastering Shiny](https://mastering-shiny.org/)

- [Galeria do Shiny](https://shiny.rstudio.com/gallery/)
